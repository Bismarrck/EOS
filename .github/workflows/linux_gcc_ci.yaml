name: Linux GCC CI

on:
  push:
    branches: [ main ] # Adjust branches as needed
  pull_request:
    branches: [ main ] # Adjust branches

jobs:
  build-and-test-linux-gcc:
    runs-on: ubuntu-latest # Use the latest Ubuntu runner provided by GitHub

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4 # Use the latest version
        with:
          submodules: 'recursive' # If you have submodules like pybind11

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            gfortran \
            cmake \
            ninja-build \
            python3-dev \
            python3-pip \
            python3-pytest # For running pytest

      - name: Set up Python (for Pybind11 and Python tests)
        uses: actions/setup-python@v5
        with:
          python-version: '3.9' # Specify a Python version

      - name: Install Python packages (if any beyond pytest)
        run: |
          python3 -m pip install --upgrade pip
          # pip install -r requirements-dev.txt # If you have a requirements file

      - name: Configure CMake
        run: |
          cmake -S . -B build -G "Ninja" \
            -DCMAKE_BUILD_TYPE=Release \
            -DEOS_BUILD_TESTS=ON \
            -DEOS_BUILD_EXAMPLES=ON \
            -DEOS_BUILD_PYTHON_BINDINGS=ON \
            -DCMAKE_INSTALL_PREFIX=${{ github.workspace }}/install_dir 
            # Installs to a directory within the workspace for testing

      - name: Build Project
        run: cmake --build build --config Release --parallel

      - name: Run C++ and Fortran Tests (CTest)
        working-directory: build
        run: ctest -C Release --output-on-failure -L "cpp|fortran" -v

      - name: Install Project
        run: cmake --install build --config Release --prefix ${{ github.workspace }}/install_dir
        # The prefix here matches the one used in CMake configuration

      - name: List Installed Files (for debugging)
        run: |
          echo "Listing installed files in ${{ github.workspace }}/install_dir:"
          find ${{ github.workspace }}/install_dir -print

      # --- Test Installed Components ---
      # Option 1: Re-configure and build examples against installed library
      # This is more robust as it simulates an external project using find_package (if set up)

      - name: Configure C++ Example against Installed Library
        # This assumes your library installs a YourLibConfig.cmake for find_package
        # If not, you'd manually set CMAKE_PREFIX_PATH or hints for find_library/find_path
        run: |
          cmake -S ${{ github.workspace }}/examples/cpp_example \
                -B ${{ github.workspace }}/build_example_cpp \
                -G "Ninja" \
                -DCMAKE_BUILD_TYPE=Release \
                -DCMAKE_INSTALL_PREFIX=${{ github.workspace }}/install_dir \
                -DCMAKE_PREFIX_PATH=${{ github.workspace }}/install_dir 
                # CMAKE_PREFIX_PATH helps find_package find the installed EOSCoreConfig.cmake

      - name: Build C++ Example against Installed Library
        run: cmake --build ${{ github.workspace }}/build_example_cpp --config Release

      - name: Run C++ Example
        run: ${{ github.workspace }}/build_example_cpp/CppEOSDemo # Adjust executable name if different

      # Test Fortran Example (similar approach, might need Fortran module path adjustments)
      - name: Configure Fortran Example against Installed Library
        run: |
          cmake -S ${{ github.workspace }}/examples/fortran_example \
                -B ${{ github.workspace }}/build_example_fortran \
                -G "Ninja" \
                -DCMAKE_BUILD_TYPE=Release \
                -DCMAKE_PREFIX_PATH=${{ github.workspace }}/install_dir
                # Ensure Fortran example's CMakeLists.txt uses find_package or similar for EOSCore
                # and correctly finds the Fortran interface module if needed from source or installed location.
                # Usually, the Fortran example includes module_eos_fortran_interface.f90 source directly
                # and links against the installed C++ library (EOSCore).

      - name: Build Fortran Example against Installed Library
        run: cmake --build ${{ github.workspace }}/build_example_fortran --config Release

      - name: Run Fortran Example
        run: ${{ github.workspace }}/build_example_fortran/FortranEOSDemo # Adjust executable name

      # Test Python Module Import and Basic Usage from installed location
      - name: Test Installed Python Module
        env:
          # The Python module (PyEOS.so) should be installed to a known path by `cmake --install`
          # e.g., ${{ github.workspace }}/install_dir/lib/python_packages/PyEOS/PyEOS.cpython-XYZ.so
          # Adjust PYTHONPATH to include the parent directory of 'PyEOS' module directory
          PYTHONPATH: ${{ github.workspace }}/install_dir/lib/python_packages
          # (The exact path depends on your `install(TARGETS PyEOS ...)` destination in python/CMakeLists.txt)
        run: |
          echo "PYTHONPATH set to: $PYTHONPATH"
          python3 -c "import PyEOS; print('Successfully imported PyEOS from installed location!'); print(dir(PyEOS)); eos = PyEOS.EquationOfState(); print('Created PyEOS.EquationOfState instance.')"
          # You can run your examples/python_example/run_eos_demo.py here too if it uses installed module
          # python3 ${{ github.workspace }}/examples/python_example/run_eos_demo.py

      # (Optional) Run Python numerical tests against installed module if they are separate
      - name: Run Python Numerical Tests against Installed Module
        env:
          PYTHONPATH: ${{ github.workspace }}/install_dir/lib/python_packages
        run: |
          echo "Running Python numerical tests with PYTHONPATH=$PYTHONPATH"
          python3 -m pytest ${{ github.workspace }}/tests/python_tests/test_pyeos_numerical.py